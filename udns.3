.\" $Id: udns.3,v 1.3 2004/06/28 20:35:25 mjt Exp $
.\" libdns manpage
.\"
.TH libdns 3 "Jun 2004" "Library Functions"

.SH NAME
libdns \- stub DNS resolver library

.SH SYNOPSYS
.nf
#include <dns.h>
struct dns_ctx;
struct dns_query;
extern struct dns_ctx dns_defctx;

\fBcc\fR ... -l\fBdns\fR
.fi

.SH DESCRIPTION

.PP
The DNS library, \fBlibdns\fR, implements thread\-safe stub DNS resolver
functionality, which may be used both traditional, syncronous way
and asyncronously, with application\-supplied event loop.

.PP
While DNS works with both TCP and UDP, performing UDP query first and
if the result does not fit in UDP buffer (512 bytes max for original
DNS protocol), retrying the query over TCP, the library uses UDP only,
but uses EDNS0 (RFCxxx) extensions which allows larger UDP buffers.

.PP
The library uses single UDP socket to perform all operations even when
asking multiple nameservers.  This way, it is very simple to use the
library in asyncronous event\-loop applications: an application should
add only single socket to the set of filedescriptors it monitors for I/O.

.PP
The library uses two main objects, \fIresolver context\fR of type
\fBstruct\ dns_ctx\fR, and \fIquery\fR of type \fBstruct\ dns_query\fR.
Resolver context holds global information about the resolver, such as
list of nameservers to use, list of active requests and the like.

.PP
Internally, library uses on\-wire format of domain names, referred
to as \fIDN format\fR in this manual page.  This is a series of domain
\fIlabels\fR whith preceeding length byte, terminated by zero\-length
label wich is integral part of the DN format.  There are several routines
provided to convert from traditional asciiz string to DN and back.

.SS "Miscellaneous constants"

.PP
The following constants are defined in dns.h header file:
Maximum length of the domain name in internal (on\-wire) format.
.IP "\fBDNS_MAXLABEL\fR (63 bytes)"
Maximum length of a single label in DN format.
.IP "\fBDNS_MAXNAME\fR (1024 bytes)"
Maximum length of asciiz format of a domain name.
.IP "\fBDNS_HSIZE\fR (12 bytes)"
Size of header in DNS packet.
.IP "\fBDNS_PORT\fR (53)"
Default port to use when contacting a DNS server.
.IP "\fBDNS_MAXSERV\fR (6 servers)"
Maximum number of DNS servers to use.
.IP "\fBDNS_MAXSRCH\fR (5 search list entries)"
Maximum number of domain search list
.IP "\fBDNS_MAXPACKET\fR (512 bytes)"
Maximum length of DNS UDP packet as specified by original DNS protocol
.IP "\fBDNS_EDNS0PACKET\fR (4096 bytes)"
Default length of DNS UDP packet (with EDNS0 extensions) the library uses.
Note that recursive nameservers usually resides near the client asking them
to resolve names, e.g. on the same LAN segment or even on the same host, so
UDP packet fragmentation isn't a problem in most cases.  Note also that
the size of actual packets will be as many bytes as actual reply size requires,
which is smaller than this value in almost all cases.

.SS "DNS Classes and Types"
.PP
Every DNS Resource Record (RR) has a \fItype\fR and a \fIclass\fR.
The library defines several integer constants, prefixed by \fBDNS_C_\fR and
\fBDNS_T_\fR, to use as symbolic names for RR classes and types,
such as \fBDNS_C_IN\fR for Internet class, \fBDNS_T_A\fR for IPv4
address record type and so on.  See dns.h for complete list of all
such constants.

.SS "Domain Names (DNs)"

.PP
A DN is a series of domain name labels each starts with length byte,
followed by empty label (label with zero length).  The following
routines to work with DNs are provided.  This is a low\-level interface.

.PP
.nf
unsigned \fBdns_dnlen\fR(const unsigned char *\fIdn\fR)
.fi
.RS
return length of the domain name \fIdn\fR, including the terminating label.
.RE

.PP
.nf
unsigned \fBdns_dnlabels\fR(const unsigned char *\fIdn\fR)
.fi
.RS
return number of non\-zero labels in domain name \fIdn\fR.
.RE

.PP
.nf
unsigned \fBdns_dnequal\fR(\fIdn1\fR, \fIdn2\fR)
  const unsigned char *\fIdn1\fR, *\fIdn2\fR;
.fi
.RS
test whenever the two domain names, \fIdn1\fR and \fIdn2\fR, are
equal (case\-insensitive).  Return domain name length if equal
or 0 if not.
.RE

.PP
.nf
unsigned \fBdns_dntodn\fR(\fIsdn\fR, \fIddn\fR, \fIddnsiz\fR)
  const unsigned char *\fIsdn\fR;
  unsigned char *\fIddn\fR;
  unsigned \fIddnsiz\fR;
.fi
.RS
copies the source domain name \fIsdn\fR to destination buffer \fIddn\fR
of size \fIddnsiz\fR.  Return domain name length or 0 if \fIddn\fR is
too small.
.RE

.PP
.nf
int \fBdns_ptodn\fR(\fIname\fR, \fInamelen\fR, \fIdn\fR, \fIdnsiz\fR, \fIisabs\fR)
int \fBdns_sptodn\fR(\fIname\fR, \fIdn\fR, \fIdnsiz\fR)
  const char *\fIname\fR; unsigned \fInamelen\fR;
  unsigned char *\fIdn\fR; unsigned \fIdnsiz\fR;
  int *\fIisabs\fR;
.fi
.RS
convert asciiz name \fIname\fR of length \fInamelen\fR to DN format,
placing result into buffer \fIdn\fR of size \fIdnsiz\fR.  Return
length of the DN if successeful, 0 if the \fIdn\fR buffer supplied is
too small, or negative value if \fIname\fR is invalid.  If \fIisabs\fR
is non\-NULL and conversion was successeful, *\fIisabs\fR will be set to
either 1 or 0 depending whenever \fIname\fR was absolute (i.e. ending with
a dot) or not.  Name length, \fInamelength\fR, may be zero, in which case
strlen(\fIname\fR) will be used.  Second form, \fBdns_sptodn\fR(), is a
simplified form of \fBdns_ptodn\fR(), equivalent to
.br
.nf
\fBdns_ptodn\fR(\fIname\fR, 0, \fIdn\fR, \fIdnlen\fR, 0).
.fi
.RE

.PP
.nf
extern const unsigned char \fBdns_inaddr_arpa_dn\fR[]
int \fBdns_a4todn\fR(const struct in_addr *\fIaddr\fR, const unsigned char *\fItdn\fR,
      unsigned char *\fIdn\fR, unsigned \fIdnsiz\fR)
int \fBdns_a4ptodn\fR(const struct in_addr *\fIaddr\fR, const char *\fItname\fR,
      unsigned char *\fIdn\fR, unsigned \fIdnsiz\fR)
extern const unsigned char \fBdns_ip6_arpa_dn\fR[]
int \fBdns_a6todn\fR(const struct in6_addr *\fIaddr\fR, const unsigned char *\fItdn\fR,
      unsigned char *\fIdn\fR, unsigned \fIdnsiz\fR)
int \fBdns_a6ptodn\fR(const struct in6_addr *\fIaddr\fR, const char *\fItname\fR,
      unsigned char *\fIdn\fR, unsigned \fIdnsiz\fR)
.fi
.RS
several variants of routines to convert IPv4 and IPv6 address \fIaddr\fR
into reverseDNS\-like domain name in DN format, storing result in \fIdn\fR
of size \fIdnsiz\fR.  \fItdn\fR (or \fItname\fR) is the base zone name,
like in-addr.arpa for IPv4 or in6.arpa for IPv6.  If \fItdn\fR (or \fItname\fR)
is NULL, \fBdns_inaddr_arpa_dn\fR (or \fBdns_ip6_arpa_dn\fR) will be used.
The routines may be used to construct a DN for a DNSBL lookup for example.
All routines return length of the resulting DN on success, -1 if resulting
DN is invalid, or 0 if the \fIdn\fR buffer (\fIdnsiz\fR) is too small.
To hold standard rDNS DN, a buffer of size \fBDNS_A4RSIZE\fR (30 bytes) for
IPv4 address, or \fBDNS_A6RSIZE\fR (74 bytes) for IPv6 address, is sufficient.
.RE

.PP
.nf
int \fBdns_dntop\fR(\fIdn\fR, \fIname\fR, \fInamesiz\fR)
   const unsigned char *\fIdn\fR;
   const char *\fIname\fR; unsigned \fInamesiz\fR;
.fi
.RS
convert domain name \fIdn\fR in DN format to asciiz string, placing result
into \fIname\fR buffer of size \fInamesiz\fR.  Maximum length of asciiz
representation of domain name is \fBDNS_MAXNAME\fR (1024) bytes.  Root
domain is represented as empty string.  Return length of the resulting name
(including terminating character, i.e. strlen(name)+1) on success, 0 if the
\fIname\fR buffer is too small, or negative value if \fIdn\fR is invalid
(last case should never happen since all routines in this library which
produce domain names ensure the DNs generated are valid).
.RE

.PP
.nf
const char *\fBdns_dntosp\fR(const unsigned char *\fIdn\fR)
.fi
.RS
convert domain name \fIdn\fR in DN format to asciiz string using static
buffer.  Return the resulting asciiz string on success or NULL on failure.
Note since this routine uses static buffer, it is not thread\-safe.
.RE

.PP
.nf
unsigned \fBdns_dntop_size\fR(const unsigned char *\fIdn\fR)
.fi
.RS
return the buffer size needed to convert the \fIdn\fR domain name
in DN format to asciiz string, for \fBdns_dntop\fR().  The routine
return either the size of buffer required, including the trailing
zero byte, or 0 if \fIdn\fR is invalid.
.RE

.SS "Working with DNS Packets"

.PP
The following routines are provided to encode and decode DNS on\-wire
packets.  This is low\-level interface.

.PP
DNS response codes (returned by \fBdns_rcode\fR() routine) are
defined as constants prefixed with \fBDNS_R_\fR.  See dns.h
header file for the complete list.  In particular, constants
\fBDNS_R_NOERROR\fR (0), \fBDNS_R_SERVFAIL\fR, \fBDNS_R_NXDOMAIN\fR
may be of interest to an application.

.PP
.nf
unsigned \fBdns_get16\fR(const unsigned char *\fIp\fR)
unsigned \fBdns_get32\fR(const unsigned char *\fIp\fR)
.fi
.RS
helper routines, convert 16\-bit or 32\-bit integer in on\-wire
format pointed to by \fIp\fR to unsigned.
.RE

.PP
.nf
unsigned char *\fBdns_put16\fR(unsigned char *\fId\fR, unsigned \fIn\fR)
unsigned char *\fBdns_put32\fR(unsigned char *\fId\fR, unsigned \fIn\fR)
.fi
.RS
helper routine, convert unsigned 16\-bit or 32\-bit integer \fIn\fR to
on\-wire format to buffer pointed to by \fId\fR, return \fId\fR+2 or
\fId\fR+4.
.RE

.PP
.nf
\fBDNS_HSIZE\fR (12)
.fi
.RS
defines size of DNS header.  Data section
in the DNS packet immediately follows the header.  In the header,
there are query identifier (id), various flags and codes,
and number of resource records in various data sections.
See dns.h header file for complete list of DNS header definitions.
.RE

.PP
.nf
unsigned \fBdns_qid\fB(const unsigned char *\fIpkt\fR)
int \fBdns_rd\fB(const unsigned char *\fIpkt\fR)
int \fBdns_tc\fB(const unsigned char *\fIpkt\fR)
int \fBdns_aa\fB(const unsigned char *\fIpkt\fR)
int \fBdns_qr\fB(const unsigned char *\fIpkt\fR)
int \fBdns_ra\fB(const unsigned char *\fIpkt\fR)
unsigned \fBdns_opcode\fB(const unsigned char *\fIpkt\fR)
unsigned \fBdns_rcode\fB(const unsigned char *\fIpkt\fR)
unsigned \fBdns_numqd\fB(const unsigned char *\fIpkt\fR)
unsigned \fBdns_numan\fB(const unsigned char *\fIpkt\fR)
unsigned \fBdns_numns\fB(const unsigned char *\fIpkt\fR)
unsigned \fBdns_numar\fB(const unsigned char *\fIpkt\fR)
const unsigned char *\fBdns_payload\fR(const unsigned char *\fIpkt\fR)
.fi
.RS
return various parts from the DNS packet header \fIpkt\fR:
query identifier (qid),
recursion desired (rd) flag,
truncation occured (tc) flag,
authoritative answer (aa) flag,
query response (qr) flag,
recursion available (ra) flag,
operation code (opcode),
result code (rcode),
number of entries in question section (numqd),
number of answers (numan),
number of authority records (numns),
number of additional records (numar),
and the pointer to the packet data (payload).
.RE

.PP
.nf
int \fBdns_getdn\fR(\fIpkt\fR, \fIcurp\fR, \fIpkte\fR, \fIdn\fR, \fIdnsiz\fR)
const unsigned char *\fBdns_skipdn\fR(\fIcur\fR, \fIpkte\fR)
   const unsigned char *\fIpkt\fR, *\fIpkte\fR, **\fIcurp\fR, *\fIcur\fR;
   unsigned char *\fIdn\fR; unsigned \fIdnsiz\fR;
.fi
.RS
\fBdns_getdn\fR() extract DN from DNS packet \fIpkt\fR which ends before
\fIpkte\fR starting at position *\fIcurp\fR into buffer pointed to by
\fIdn\fR of size \fIdnsiz\fR.  Upon successeful completion, *\fIcurp\fR
will point to the next byte in the packet after the extracted domain name.
It return positive number (length of the DN if \fIdn\fR) upon successeful
completion, negative value on error (when the packet contains invalid data),
or zero if the \fIdnsiz\fR is too small (maximum length of a domain name is
\fBDNS_MAXDN\fR).  \fBdns_skipdn\fR() return pointer to the next byte in
DNS packet which ends up before \fIpkte\fR after a domain name which starts
at the \fIcur\fP byte, or NULL if the packet is invalid.  \fBdns_skipdn\fR()
is more or less equivalent to what \fBdns_getdn\fR() does, except it does not
actually extract the domain name in question, and uses simpler interface.
.RE

.PP
.B XXXXXXXXX Todo: struct dns_rr, struct dns_parse, dns_initparse(), dns_firstrr(), dns_nextrr().

.SS "Resolver Context"

.PP
Resolver context, of type \fBstruct\ dns_ctx\fR, is an object which is
opaque to the application.  Several routines provided by the library
to initialize, copy and free resolver contexts.  Most other high\-level
routines in this library expects a pointer to resolver context, \fIctx\fR,
as the first argument.  There is a default resolver context available,
named \fBdns_defctx\fR.  When the context pointer \fIctx\fR passed to
a routine is NULL, \fBdns_defctx\fR is used.  Several resolver contexts
may be active at the same time, for example, when an application is
multi\-threaded and each thread uses resolver.  An application is not
required to initialize default context, it is done by the library
automatically.
.PP
When initializing resolver context, the library uses information from
system file /etc/resolv.conf (see \fBresolv.conf\fR(5)), consults
environment variables \fB$LOCALDOMAIN\fR, \fB$DNSCACHEIP\fR,
\fB$NAMESERVERS\fR and \fB$RES_OPTIONS\fR, and local host name to obtain
list of local nameservers, domain name search list and various resolver
options.
.PP
The following routines to initialize resolver context are available:
.PP
.nf
void \fBdns_init\fR(void)
struct dns_ctx *\fBdns_new\fR(struct dns_ctx *\fIcopy\fR)
void \fBdns_free\fR(struct dns_ctx *\fIctx\fR)
.fi
.RS
\fBdns_init\fR() initializes default resolver context, \fBdns_defctx\fR.
It is ok to call \fBdns_init\fR() more than once, it will do nothing
if \fBdns_defctx\fR is already initialized.
\fBdns_new\fR() makes a copy of a given resolver context \fIcopy\fR, or
default context if \fIcopy\fR is NULL, and returns pointer to it.
\fBdns_new\fR() may fail if there's no memory available to make a copy
of \fIcopy\fR, in which case the routine will return NULL pointer.
\fBdns_free\fR() is used to close assotiated socket and free resolver context
resources.  It is an error to call this routine while there are
active queries assotiated with the resolver context.  It's ok to
free \fBdns_defctx\fR as well as dynamically allocated contexts
returned by \fBdns_new\fR().
.RE
.PP
.nf
int \fBdns_set_serv\fR(struct dns_ctx *\fIctx\fR, const char *\fIserv\fR[])
int \fBdns_set_srch\fR(struct dns_ctx *\fIctx\fR, const char *\fIsrch\fR[])
.fi
.RS
Set the list of nameservers (\fBdns_set_serv\fR()) and search list
(\fBdns_set_srch\fR()) for the given context \fIctx\fR.  Both
\fIsrv\fR and \fIsrch\fR is an argv\-style list of strings, holding
IP addresses of nameservers to use and domain names in search list.
Current values in \fIctx\fR are replaced with the given ones.  It is
an error to call either of this functions if there's at least one
query is queued for \fIctx\fR.
.RE
.PP
.nf
int \fBdns_set_opts\fR(struct dns_ctx *\fIctx\fR, const char *\fIopts\fR)
.fi
.RS
set resolver context options from \fIopts\fR string, in the same way as
processing \fBoptions\fR statement in resolv.conf and \fB$RES_OPTIONS\fR
environment variable.
.RE
.PP
.nf
void \fBdns_set_opt\fR(struct dns_ctx *\fIctx\fR, int \fIopt\fR, \fIval\fR)
.fi
.RS
.B TODO
The \fIflags\fR argument is a bitmask with the following bits defined:
.IP \fBDNS_NOSRCH\fR
do not perform domain name search in search list.
.IP \fBDNS_NORD\fR
do not request recursion when performing queries
(i.e. don't set RD flag in querues).
.IP \fBDNS_AAONLY\fR
request authoritative answers only (i.e. set AA
flag in queries).
.RE

.PP
.nf
int \fBdns_open\fR(struct dns_ctx *\fIctx\fR)
int \fBdns_sock\fR(const struct dns_ctx *\fIctx\fR)
void \fBdns_close\fR(struct dns_ctx *\fIctx\fR)
.fi
.RS
\fBdns_open\fR() opens the UDP socket used for queries if not already
open, and return assotiated filedescriptor (or negative value in case
of error).
\fBdns_sock\fR() return the UDP socket if open, or -1 if not.
\fBdns_close\fR() closes the UDP socket if it was open.
.RE

.PP
.nf
void \fBdns_ioevent\fR(struct dns_ctx *\fIctx\fR, time_t \fInow\fR)
.fi
.RS
this routine may be called by an application to process I/O
events on the UDP socket used by the library, as returned
by \fBdns_sock\fR().  The routine tries to receive incoming
UDP datagram from the socket and process it.  The socket is
set up to be non\-blocking, so it is safe to call the routine
even if there's no data to read.  The routine will process
as many datagrams as are queued for the socket, so it is
safe to use it with either level\-triggered or edge\-triggered
I/O monitoring model.  The \fInow\fR argument is either a
current time as returned by \fBtime\fR(), or 0, in which
case the routine will obtain current time by it's own.
.RE

.PP
.nf
int \fBdns_timeouts\fR(struct dns_ctx *\fIctx\fR, int \fImaxwait\fR, time_t \fInow\fR)
.fi
.RS
process any pending timeouts and return number of secounds
from current time (\fInow\fR if it is not 0) to the time when
the library wants the application to pass it control to process
more queued requests.  In case when there are no requests pending,
this time is -1.  The routine will not request a time larger than
\fImaxwait\fR secounds if it is greather or equal to zero.  If
\fInow\fR is 0, the routine will obtain current time by it's own;
when it is not 0, it should contain current time as returned by
\fBtime\fR().
.RE

.PP
.nf
typedef int \fBdns_utm_fn\fR(void *\fIarg\fR, struct dns_query *\fIq\fR, int \fItimeout\fR)
void \fBdns_set_cbck\fR(struct dns_ctx *\fIctx\fR, dns_utm_fn *\fIutmfn\fR, void *\fIarg\fR)
.fi
.RS
An application may use custom callback\-based I/O multiplexing mechanism.
Usually such a mechanism have concept of a \fItimer\fR, and an ability
to register a timer event in a form of a callback routine which will
be executed after certain amount of time.  In order to use such an
event mechanism, libdns provides an ability to register and de\-register
timer events necessary for internal processing using whatever event
mechanism an application uses.  For this to work, it is possible to
assotiate a pointer to a routine that will perform necessary work for
(de)registering timer events with a given resolver context, and
libdns will call that routine at appropriate times.  Prototype of
such a routine is shown by \fBdns_utm_fn\fR typedef above.  Libdns
assotiates timers with queue structure only, and there may be only
one active timer for any given queue structure.  To register timer
event, libdns will call the routine giving it the query structure
in question and non\-zero \fItimeout\fR argument.  When a timer is
not needed anymore, libdns de\-registers it by calling the same
routine with zero \fItimeout\fR.  When a timer expires, an application
should de\-register timer event and call \fBdns_tmevent\fR() routine
with the query structure as an argument.
Other, non\-callback timer usage is provided too, see below.
.RE

.PP
.nf
void \fBdns_tmevent\fR(struct dns_query *\fIq\fR, time_t \fInow\fR);
.fi
.RS
routine which should be called from event\-driven application
event loop when a timer set using routine set up by
\fBdns_set_cbck\fR() expires.
.RE

.PP
.B XXXX TODO: some more resolver context routines, like dns_set_dbgfn(), dns_numreq() etc.

.SS "The Query Structure"

The \fBstruct\ dns_query\fR query structure is an opaque object used by dns
library to perform queries.  The query object is owned by application.

.SS "Making Generic Queries"

.PP
There are two ways to perform DNS queries: traditional syncronous
way, when libdns performs all the necessary processing and return
control to the application only when the query completes, and
asyncronous way, when an application submits one or more queries
to the library using given resolver context, and waits for completion
by monitoring filedescriptor used by library and calling library
routines to process input on that filedescriptor.  Asyncronous mode
works either with callbacks, when the library calls application\-supplied
callback routine upon query completion, or an application may "polls"
the library, asking to return the next completed query when the
socket becomes readable or timeout occurs.

.PP
Queries are submitted to the library in a form of \fBstruct\ dns_query\fR.
To perform asyncronous query, an application allocates memory for the
\fIquery structure\fR and passes it to the library using \fBdns_submit\fR()
routines, together with all the query parameters.  When the query completes,
library will call application\-supplied callback routine, giving it the
query in question, result status value and dynamically allocated result,
which will be either raw DNS packet or, if applicatin requested parsing
the result by specifying non-NULL parse routine, ready-to-use type-specific
structure.  It is the application who's responsible for freeing the result
memory.  Alternatively, an application may pass NULL for the query callback
routine, in which case it will be able to retrieve completed queries using
\fBdns_pick\fR() routine, wich retrieves the same information as callback
receives.  After the query completes, an application may free query
structure or reuse it for other queries.
.PP
In case of error, query completion \fBstatus\fR will contain one of the
following values:
.IP \fBDNS_E_TEMPFAIL\fR
temporary error, the resolver nameserver was not able to
process our query or timed out.
.IP \fBDNS_E_PROTOCOL\fR
protocol error, a nameserver returned malformed reply.
.IP \fBDNS_E_NXDOMAIN\fR
the domain name does not exist.
.IP \fBDNS_E_NODATA\fR
there is no data of requested type found.
.IP \fBDNS_E_NOMEM\fR
out of memory while processing request.
.IP \fBDNS_E_BADQUERY\fR
some aspect of the query (most common is the domain name in question)
is invalid, and the library can't even start a query.

.PP
.nf
int \fBdns_submit_dn\fR(\fIctx\fR, \fIq\fR,
     const unsigned char *\fIdn\fR, \fIqcls\fR, \fIqtyp\fR, \fIflags\fR,
     \fIcbck\fR, \fIparse\fR, \fInow\fR)
int \fBdns_submit_p\fR(\fIctx\fR, \fIq\fR,
     const char *\fIname\fR, \fIqcls\fR, \fIqtyp\fR, \fIflags\fR,
     \fIcbck\fR, \fIparse\fR, \fInow\fR)
   struct dns_ctx *\fIctx\fR;
   struct dns_query *\fIq\fR;
   enum dns_class \fIqcls\fR;
   enum dns_type \fIqtyp\fR;
   int \fIflags\fR;
   dns_query_fn *\fIcbck\fR;
   dns_parse_fn *\fIparse\fR;
   time_t \fInow\fR;
.fi
.RS
submit query \fIq\fR for processing for the given resolver context \fIctx\fR.
Two routines differs only in 3rd argument, which is domain name in either
DN format (\fIdn\fR) or asciiz string (\fIname\fR).  The query will be
performed for the given domain name, with type \fIqtyp\fR in class \fIqcls\fR,
using option bits in \fIflags\fR, using RR parsing routine pointed by
\fIparse\fR if not-NULL, and upon completion, \fIcbck\fR function will
be called.  The \fInow\fR argument specifies current time as returned by
\fBtime\fR() routine, used to minimize number of system calls performed by
an application; if \fInow\fR is 0, the routine will obtain current time by
it's own.  In case of successeful query submission, the routine return 0.
In case of error (which may means it was unable to open UDP socket,
or unable to allocate memory, or when the query was invalid), the routine
returns negative value
.B TODO: DNS_E_XXX constants.
.RE

.PP
.nf
void *\fBdns_resolve_dn\fR(\fIctx\fR,
    const unsigned char *\fIdn\fR, \fIqcls\fR, \fIqtyp\fR, \fIflags\fR,
    \fIparse\fR, \fIstatusp\fR);
void *\fBdns_resolve_p\fR(\fIctx\fR,
    const char *\fIname\fR, \fIqcls\fR, \fIqtyp\fR, \fIflags\fR,
    \fIparse\fR, \fIstatusp\fR);
  int *\fIstatusp\fR;
.fi
.RS
syncronous interface.  The routine performs all the steps
necessary to resolve the given query and return the result,
setting query completion code to *\fIstatusp\fR if it is
non-NULL.  If there's no positive result for any reason,
the routine return NULL.
.RE
.PP
.nf
void \fBdns_cancel\fR(struct dns_query *\fIq\fR)
.fi
.RS
cancel an active query \fIq\fR.
.RE
.PP
.nf
int \fBdns_active\fR(const struct dns_query *\fIq\fR)
.fi
.RS
return true if the given query \fIq\fR is active, that
is, it is queued for the processing, or false if it is not.
.RE
